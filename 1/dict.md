## Dict Class MRO  
Словарь в Python (dict) — это одна из самых мощных, гибких и важных структур данных. Под капотом dict использует хеш-таблицу, что позволяет обеспечивать операции добавления, поиска и удаления элементов с очень высокой эффективностью, в среднем за время O(1), то есть время выполнения операции не зависит от размера словаря.

Как Работает dict:
Хеширование: Ключи словаря хешируются с помощью хеш-функции, которая преобразует ключи в индексы в массиве хеш-таблицы. Хеш-функция должна быстро вычисляться и равномерно распределять ключи по таблице.
`__hash__` - если хотим что бы наш класс мог использоваться в качестве ключа в словаре надо реализовать этот метод.


Разрешение Коллизий: Коллизии происходят, когда два ключа имеют один и тот же хеш. Python использует метод открытой адресации с линейным пробированием для разрешения коллизий: если для ключа предназначенная ячейка занята, алгоритм пробует следующую ячейку, пока не найдет свободную.

Динамическое Изменение Размера: Чтобы поддерживать эффективность операций, Python динамически изменяет размер хеш-таблицы. При добавлении элементов и при достижении определенного порога заполненности, размер таблицы увеличивается, и элементы перехешируются в новую, большую таблицу.

Плюсы и Минусы Подхода:
Плюсы:

Эффективность: Операции добавления, поиска и удаления в среднем выполняются за константное время O(1).
Гибкость: Словари могут хранить объекты разных типов как ключи и значения.
Интуитивность: Интерфейс словаря прост и понятен, что делает его удобным в использовании.
Минусы:

Потребление Памяти: Хеш-таблицы потребляют больше памяти, чем другие структуры данных, для поддержки быстрого доступа.
Хеш-функции: Не все объекты могут быть ключами словаря. Ключи должны быть хешируемыми, то есть неизменяемыми в течение жизни элемента



### `__hash__` in python 
В Python метод `__hash__` используется для получения хеш-значения объекта, что позволяет его использовать в качестве ключа в словарях или элемента в множествах. При написании собственных классов и определении метода `__hash__`, важно соблюдать несколько правил:

Если два объекта считаются равными при сравнении с помощью `__eq__`, их хеш-значения также должны быть равными.
Хеш-значение объекта не должно изменяться во время его жизни, даже если изменяются его атрибуты. Это означает, что объекты, используемые в качестве ключей словаря, должны быть неизменяемыми по отношению к используемым для хеширования атрибутам.
Метод `__hash__` должен возвращать целое число.
### Пример 1: Простой Класс с `__hash__`
```
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def __eq__(self, other):
        return isinstance(other, Person) and self.name == other.name and self.age == other.age
    
    def __hash__(self):
        return hash((self.name, self.age))
        
p1 = Person('Alice', 30)
p2 = Person('Bob', 25)
my_dict = {p1: 'Programmer', p2: 'Engineer'}
print(my_dict[p1])  # Выведет 'Programmer'
```
### Пример 2: Класс с Изменяемым Состоянием
Если класс содержит изменяемые атрибуты, которые используются в `__hash__`, следует продумать логику его использования, чтобы избежать изменений этих атрибутов в процессе жизни объекта, когда он используется как ключ словаря или элемент множества.
```
class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price

    def __eq__(self, other):
        return isinstance(other, Product) and self.name == other.name

    def __hash__(self):
        return hash(self.name)

product = Product('Laptop', 1000)
products_set = {product}
print(product in products_set)  

product.price = 900  
print(product in products_set)  # По-прежнему True, потому что хеш не изменился
```
Важные Моменты
В Python, если вы переопределяете ``__eq__,`` рекомендуется также переопределить `__hash__`, чтобы объекты вашего класса могли использоваться в словарях и множествах.


Почему нам иногда выгодно использовать хеши: 
Оптимизация Производительности: Правильная реализация `__hash__ `может повысить производительность при работе со сложными структурами данных, особенно когда требуется быстрый поиск и вставка элементов(например мы можем закинуть это все в `set`).

Когда работаешь с классами в Python, каждый экземпляр имеет внутренний словарь (__dict__), где хранятся его атрибуты и методы. Это ключевая часть языка, позволяющая динамически управлять атрибутами объектов.

### `__dict__ `и классы
Когда определяешь класс, Python использует `__dict__` для хранения его атрибутов и методов. Это делает структуру класса гибкой, позволяя добавлять, изменять и удалять атрибуты в реальном времени.

Наследование и `__dict__`
В механизме наследования Python также использует словари для отслеживания атрибутов и методов классов-предков. Это позволяет экземпляру класса обращаться к методам и атрибутам родительских классов, если они не переопределены в дочернем классе.

Производительность
Несмотря на удобство, использование `__dict__` влияет на производительность из-за дополнительных расходов на хранение и доступ к атрибутам через словарь. Это особенно заметно при создании большого количества экземпляров класса.
### Mro class
Говоря про классы мы сразу указываем что питон интересный язык и в нем можно использовать множественное наследование. Для решения проблем связанных с этим юзается MRO. Пока что я вам это рассказывать не буду. Но тамидея в том что мы должны чем-то походим на bfs искать реализацию методов.

    
